'use strict';

// Load Date class extensions
var CronDate = require('./date');

var stringifyField = require('./field_stringify');

/**
 * Cron iteration loop safety limit
 */
var LOOP_LIMIT = 10000;

/**
 * Construct a new expression parser
 *
 * Options:
 *   currentDate: iterator start date
 *   endDate: iterator end date
 *
 * @constructor
 * @private
 * @param {Object} fields  Expression fields parsed values
 * @param {Object} options Parser options
 */
function CronExpression (fields, options) {
  this._options = options;
  this._utc = options.utc || false;
  this._tz = this._utc ? 'UTC' : options.tz;
  this._currentDate = new CronDate(options.currentDate, this._tz);
  this._startDate = options.startDate ? new CronDate(options.startDate, this._tz) : null;
  this._endDate = options.endDate ? new CronDate(options.endDate, this._tz) : null;
  this._isIterator = options.iterator || false;
  this._hasIterated = false;
  this._nthDayOfWeek = options.nthDayOfWeek || 0;
  this.fields = CronExpression._freezeFields(fields);
}

/**
 * Field mappings
 * @type {Array}
 */
CronExpression.map = [ 'second', 'minute', 'hour', 'dayOfMonth', 'month', 'dayOfWeek' ];

/**
 * Prefined intervals
 * @type {Object}
 */
CronExpression.predefined = {
  '@yearly': '0 0 1 1 *',
  '@monthly': '0 0 1 * *',
  '@weekly': '0 0 * * 0',
  '@daily': '0 0 * * *',
  '@hourly': '0 * * * *'
};

/**
 * Fields constraints
 * @type {Array}
 */
CronExpression.constraints = [
  { min: 0, max: 59, chars: [] }, // Second
  { min: 0, max: 59, chars: [] }, // Minute
  { min: 0, max: 23, chars: [] }, // Hour
  { min: 1, max: 31, chars: ['L'] }, // Day of month
  { min: 1, max: 12, chars: [] }, // Month
  { min: 0, max: 7, chars: ['L'] }, // Day of week
];

/**
 * Days in month
 * @type {number[]}
 */
CronExpression.daysInMonth = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];

/**
 * Field aliases
 * @type {Object}
 */
CronExpression.aliases = {
  month: {
    jan: 1,
    feb: 2,
    mar: 3,
    apr: 4,
    may: 5,
    jun: 6,
    jul: 7,
    aug: 8,
    sep: 9,
    oct: 10,
    nov: 11,
    dec: 12
  },

  dayOfWeek: {
    sun: 0,
    mon: 1,
    tue: 2,
    wed: 3,
    thu: 4,
    fri: 5,
    sat: 6
  }
};

/**
 * Field defaults
 * @type {Array}
 */
CronExpression.parseDefaults = [ '0', '*', '*', '*', '*', '*' ];

CronExpression.standardValidCharacters = /^[,*\d/-]+$/;
CronExpression.dayOfWeekValidCharacters = /^[?,*\dL#/-]+$/;
CronExpression.dayOfMonthValidCharacters = /^[?,*\dL/-]+$/;
CronExpression.validCharacters = {
  second: CronExpression.standardValidCharacters,
  minute: CronExpression.standardValidCharacters,
  hour: CronExpression.standardValidCharacters,
  dayOfMonth: CronExpression.dayOfMonthValidCharacters,
  month: CronExpression.standardValidCharacters,
  dayOfWeek: CronExpression.dayOfWeekValidCharacters,
};

CronExpression._isValidConstraintChar = function _isValidConstraintChar(constraints, value) {
  if (typeof value !== 'string') {
    return false;
  }

  return constraints.chars.some(function(char) {
    return value.indexOf(char) > -1;
  });
};

/**
 * Parse input interval
 *
 * @param {String} field Field symbolic name
 * @param {String} value Field value
 * @param {Array} constraints Range upper and lower constraints
 * @return {Array} Sequence of sorted values
 * @private
 */
CronExpression._parseField = function _parseField (field, value, constraints) {
  // Replace aliases
  switch (field) {
    case 'month':
    case 'dayOfWeek':
      var aliases = CronExpression.aliases[field];

      value = value.replace(/[a-z]{3}/gi, function(match) {
        match = match.toLowerCase();

        if (typeof aliases[match] !== 'undefined') {
          return aliases[match];
        } else {
          throw new Error('Validation error, cannot resolve alias "' + match + '"');
        }
      });
      break;
  }

  // Check for valid characters.
  if (!(CronExpression.validCharacters[field].test(value))) {
    throw new Error('Invalid characters, got value: ' + value);
  }

  // Replace '*' and '?'
  if (value.indexOf('*') !== -1) {
    value = value.replace(/\*/g, constraints.min + '-' + constraints.max);
  } else if (value.indexOf('?') !== -1) {
    value = value.replace(/\?/g, constraints.min + '-' + constraints.max);
  }

  //
  // Inline parsing functions
  //
  // Parser path:
  //  - parseSequence
  //    - parseRepeat
  //      - parseRange

  /**
   * Parse sequence
   *
   * @param {String} val
   * @return {Array}
   * @private
   */
  function parseSequence (val) {
    var stack = [];

    function handleResult (result) {
      if (result instanceof Array) { // Make sequence linear
        for (var i = 0, c = result.length; i < c; i++) {
          var value = result[i];

          if (CronExpression._isValidConstraintChar(constraints, value)) {
            stack.push(value);
            continue;
          }
          // Check constraints
          if (typeof value !== 'number' || Number.isNaN(value) || value < constraints.min || value > constraints.max) {
            throw new Error(
                'Constraint error, got value ' + value + ' expected range ' +
                constraints.min + '-' + constraints.max
            );
          }

          stack.push(value);
        }
      } else { // Scalar value

        if (CronExpression._isValidConstraintChar(constraints, result)) {
          stack.push(result);
          return;
        }

        var numResult = +result;

        // Check constraints
        if (Number.isNaN(numResult) || numResult < constraints.min || numResult > constraints.max) {
          throw new Error(
            'Constraint error, got value ' + result + ' expected range ' +
            constraints.min + '-' + constraints.max
          );
        }

        if (field === 'dayOfWeek') {
          numResult = numResult % 7;
        }

        stack.push(numResult);
      }
    }

    var atoms = val.split(',');
    if (!atoms.every(function (atom) {
      return atom.length > 0;
    })) {
      throw new Error('Invalid list value format');
    }

    if (atoms.length > 1) {
      for (var i = 0, c = atoms.length; i < c; i++) {
        handleResult(parseRepeat(atoms[i]));
      }
    } else {
      handleResult(parseRepeat(val));
    }

    stack.sort(CronExpression._sortCompareFn);

    return stack;
  }

  /**
   * Parse repetition interval
   *
   * @param {String} val
   * @return {Array}
   */
  function parseRepeat (val) {
    var repeatInterval = 1;
    var atoms = val.split('/');

    if (atoms.length > 2) {
      throw new Error('Invalid repeat: ' + val);
    }

    if (atoms.length